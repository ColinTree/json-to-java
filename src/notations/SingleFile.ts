import Lodash, {Dictionary} from 'lodash';
import Notation from '../Notation';
import {parseConvertOptions} from '../utils/ConvertOptions';
import J2JError from '../utils/J2JError';
import {JsonObject} from '../utils/json';
import QuickConsole from '../utils/QuickConsole';
import JavaClass from './entry/Class';
import JavaEnum from './entry/Enum';

const ACCEPTED_ENTRY_TYPES = [ 'class', 'enum' ];
const DEFAULT_DESCRIPTION_MSG = 'This java file is generated by json-to-java by ColinTree!';

export default class JavaSingleFile extends Notation {

  private fileDescription!: string[] | Dictionary<string>;
  private package!: string;
  private imports!: string[];
  private entryType!: 'class' | 'enum';
  private entry!: JavaClass | JavaEnum;

  public constructor (json: JsonObject) {
    super(json, 0, 'file root');
  }

  public toString () {
    return this.formatFileDescription() +
      (this.package.length > 0 ? `package ${this.package};\n` : '') +

      (this.imports.length > 0
        ? `\n${this.imports.map(importElement => `import ${importElement};`).join('\n')}\n`
        : '') +

      `${this.entry}\n`;
  }

  protected defineFields () {
    // indentationSize
    this.registerFieldDeprecated('indentationSize', 'convertOptions.indent');
    this.registerFieldPreprocessor('indentationSize', value => {
      if (typeof value !== 'number' && value !== 'tab') {
        QuickConsole.warnTypeWithReplacement(this, 'indentationSize', [Number, 'string "tab"'], '4');
        return 4;
      }
      return value;
    });
    const indentationSizeHandler = (indent: string | number, json: JsonObject) => {
      json.convertOptions = Lodash.merge({ indent }, json.convertOptions || {});
    };
    this.registerEnumField('indentationSize', [ 'tab' ], indentationSizeHandler);
    this.registerNumberField('indentationSize', indentationSizeHandler);

    // convertOptions
    this.registerObjectField('convertOptions', value => parseConvertOptions(this, value));

    // fileDescription
    this.fileDescription = [ DEFAULT_DESCRIPTION_MSG ];
    this.registerStringField('fileDescription', value => {
      this.fileDescription = [ DEFAULT_DESCRIPTION_MSG, value ];
    });
    this.registerArrayField('fileDescription', value => {
      this.fileDescription = Lodash.concat(
        [ DEFAULT_DESCRIPTION_MSG ],
        value.map((description, index) => {
          if (typeof description !== 'string') {
            QuickConsole.warnElementType(this, 'fileDescription', index, value.length, String);
          }
          return String(description);
        }));
    });
    this.registerObjectField('fileDescription', value => {
      this.fileDescription = Lodash.merge(
        { '~INFO~': DEFAULT_DESCRIPTION_MSG },
        Lodash.mapValues(value, (val, key) => {
          if (typeof val !== 'string') {
            QuickConsole.warnValueTypeOfKey(this, 'fileDescription', key, String);
          }
          return String(val);
        }),
      );
    });

    // package
    this.package = '';
    this.handleStringField('package');

    // imports
    this.imports = [];
    this.handleStringArrayField('imports');

    // mainClass
    this.registerFieldDeprecated('mainClass', 'entry');
    this.registerObjectField('mainClass', (value, json) => {
      json.entryType = 'class';
      json.entry = value;
      delete json.mainClass;
    });

    // otherClasses
    this.registerFieldDeprecated('otherClasses');

    // entryType
    this.entryType = 'class';
    this.registerEnumField('entryType', ACCEPTED_ENTRY_TYPES, value => {
      this.entryType = value;
    });

    // entry
    this.registerFieldMandatory('entry');
    this.registerObjectField('entry', value => {
      const EntryConstructors = {
        class: JavaClass,
        enum: JavaEnum,
      };
      this.entry = new (EntryConstructors[this.entryType])(value, 0);
      const acceptedAccessModifier = [ 'public', null ];
      if (!acceptedAccessModifier.includes(this.entry.accessModifier)) {
        throw J2JError.typeError(this, 'entry.accessModifier', acceptedAccessModifier);
      }
    });
  }

  private formatFileDescription () {
    const fileDescription = this.fileDescription;
    if (fileDescription === null) {
      return '';
    }
    let rtn = '/**\n';
    if (Array.isArray(fileDescription)) {
      fileDescription.forEach(description => {
        rtn += ` * ${description}\n`;
      });
    } else {
      Lodash.forOwn(fileDescription, (value, key) => {
        rtn += ` * ${key}: ${value}\n`;
      });
    }
    rtn += ' */\n';
    return rtn;
  }
}
